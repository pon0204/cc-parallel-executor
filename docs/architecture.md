# CC並列実行システム アーキテクチャ設計

## 1. システムアーキテクチャ概要

CC並列実行システムは、マイクロサービスアーキテクチャを採用し、各コンポーネントが独立して動作する設計となっています。

## 2. システム構成図

```
┌─────────────────────────────────────────────────────────────┐
│                    ユーザーインターフェース                    │
│  ┌─────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │プロジェクト   │  │タスク        │  │進捗ダッシュボード│  │
│  │選択画面      │  │管理画面      │  │                  │  │
│  └─────────────┘  └──────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        APIゲートウェイ                        │
└─────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        ▼                     ▼                     ▼
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│プロジェクト   │    │タスク        │    │CC管理        │
│マネージャー   │    │スケジューラー │    │オーケストレータ│
└──────────────┘    └──────────────┘    └──────────────┘
        │                     │                     │
        └─────────────────────┼─────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      データストレージ層                       │
│  ┌─────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │プロジェクト   │  │タスク        │  │実行ログ          │  │
│  │データ        │  │データ        │  │データ            │  │
│  └─────────────┘  └──────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        CC実行環境                            │
│  ┌─────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │親CC         │  │子CC #1       │  │子CC #N           │  │
│  │(Controller) │  │(Worker)      │  │(Worker)          │  │
│  └─────────────┘  └──────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## 3. コンポーネント設計

### 3.1 フロントエンド層

- **技術スタック**: Next.js, React, TypeScript
- **状態管理**: Redux Toolkit
- **UI Framework**: Tailwind CSS

### 3.2 APIゲートウェイ

- **実装**: Express.js
- **認証**: 不要（ローカル環境想定）
- **ルーティング**: RESTful API設計

### 3.3 ビジネスロジック層

#### プロジェクトマネージャー
- プロジェクトのCRUD操作
- プロジェクト設定管理
- プロジェクトコンテキスト管理

#### タスクスケジューラー
- タスクキュー管理
- 優先度ベースのスケジューリング
- タスク依存関係の解決

#### CC管理オーケストレータ
- CCインスタンスのライフサイクル管理
- リソース管理
- 負荷分散

### 3.4 データストレージ層

- **データベース**: SQLite（ローカル環境）
- **ファイルストレージ**: ローカルファイルシステム
- **キャッシュ**: In-memory cache

### 3.5 CC実行環境

#### 親CC（Controller）
- タスク定義の読み込み
- タスクの分解と割り当て
- 子CCの監視と制御
- メインブランチでの実行
- 子CCへの指示は必ず「ultrathink」キーワードで開始

#### 子CC（Worker）
- Git worktreeの作成（タスクごとに独立した作業環境）
  - 命名規則: `worktrees/task-{taskId}-{taskName}`
  - 例: `worktrees/task-001-auth-api`
- worktreeディレクトリでのClaude Code起動
- 「ultrathink」で開始される親CCからの指示を受信・解析
- 割り当てられたタスクの実行
- 進捗レポーティング
- エラーハンドリング
- タスク完了後のworktreeクリーンアップ（オプション）

#### 親子CC間通信プロトコル
- **指示フォーマット**: 
  ```
  ultrathink
  [タスク内容]
  [詳細指示]
  ```
- **ultrathinkキーワード**: 親CCから子CCへの正式な指示であることを示す必須プレフィックス
- **子CC側の処理**: ultrathinkを検出してタスク実行モードに移行

#### Worktree管理
- **作成タイミング**: 子CC起動時
- **削除タイミング**: タスク完了後（設定により保持も可能）
- **利点**: 
  - 並列実行時のファイル競合回避
  - 各タスクが独立した環境で実行
  - ブランチ切り替えなしで複数タスクを並行処理

## 4. データフロー

1. **タスク投入フロー**
   - ユーザーがタスク定義をアップロード
   - 親CCがタスクを解析
   - タスクスケジューラーがキューに登録

2. **タスク実行フロー**
   - スケジューラーがタスクを選択
   - オーケストレータが子CCを割り当て
   - 子CC用のGit worktreeを作成
   - worktreeディレクトリで子CCを起動
   - 子CCがタスクを実行
   - 結果をデータストレージに保存
   - タスク完了後、必要に応じてworktreeをクリーンアップ

3. **進捗監視フロー**
   - 子CCが進捗を定期的に報告
   - ダッシュボードがリアルタイム更新
   - 完了通知の送信

## 5. 技術選定理由

- **Next.js**: SSR/SSGサポート、開発効率の高さ
- **SQLite**: ローカル環境での軽量性、セットアップの簡便性
- **WebSocket**: リアルタイム通信の実現
- **Docker**: 環境の一貫性とポータビリティ

## 6. セキュリティ考慮事項

- ローカル環境での動作を前提
- APIキーの安全な管理
- プロセス間通信の分離
- ログファイルのアクセス制限